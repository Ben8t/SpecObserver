# Component Architecture Reference

This document contains the full React component template for SpecObserver.
When generating an artifact, use this as the structural blueprint and adapt the
embedded data to the actual spec content.

## Skeleton JSX

Below is the annotated skeleton. The agent should:
1. Replace `SPEC_DATA` with the parsed spec JSON
2. Adjust default collapsed/expanded states based on spec depth
3. Remove FileTabs if only one file is provided

```jsx
import { useState, useEffect, useRef, useCallback, useMemo } from "react";
import { Search, ChevronRight, ChevronDown, FileText, Menu, X, Copy, Check, CheckSquare, Square } from "lucide-react";

// ── Embedded spec data (generated by the agent) ──────────────────────
const SPEC_DATA = { files: [] }; // Replace with parsed spec

// ── Markdown inline renderer ─────────────────────────────────────────
function renderInlineMarkdown(text, searchQuery = "") {
  if (!text) return null;
  // Split by inline code first to avoid processing inside code spans
  const parts = text.split(/(`[^`]+`)/g);
  return parts.map((part, i) => {
    if (part.startsWith("`") && part.endsWith("`")) {
      return <code key={i} className="bg-slate-100 text-pink-600 px-1.5 py-0.5 rounded text-xs font-mono">{part.slice(1, -1)}</code>;
    }
    // Bold
    let processed = part;
    const elements = [];
    const regex = /(\*\*(.+?)\*\*)|(\*(.+?)\*)|(\[([^\]]+)\]\(([^)]+)\))/g;
    let lastIndex = 0;
    let match;
    while ((match = regex.exec(processed)) !== null) {
      if (match.index > lastIndex) {
        elements.push(highlightSearch(processed.slice(lastIndex, match.index), searchQuery, `${i}-${lastIndex}`));
      }
      if (match[1]) { // bold
        elements.push(<strong key={`${i}-b-${match.index}`} className="font-semibold text-slate-900">{highlightSearch(match[2], searchQuery, `${i}-b-${match.index}`)}</strong>);
      } else if (match[3]) { // italic
        elements.push(<em key={`${i}-i-${match.index}`}>{highlightSearch(match[4], searchQuery, `${i}-i-${match.index}`)}</em>);
      } else if (match[5]) { // link
        elements.push(<a key={`${i}-a-${match.index}`} href={match[7]} className="text-blue-600 underline hover:text-blue-800" target="_blank" rel="noreferrer">{match[6]}</a>);
      }
      lastIndex = match.index + match[0].length;
    }
    if (lastIndex < processed.length) {
      elements.push(highlightSearch(processed.slice(lastIndex), searchQuery, `${i}-end`));
    }
    return elements.length > 0 ? <span key={i}>{elements}</span> : highlightSearch(part, searchQuery, `${i}-plain`);
  });
}

function highlightSearch(text, query, key) {
  if (!query || !text) return <span key={key}>{text}</span>;
  const idx = text.toLowerCase().indexOf(query.toLowerCase());
  if (idx === -1) return <span key={key}>{text}</span>;
  return (
    <span key={key}>
      {text.slice(0, idx)}
      <mark className="bg-yellow-200 rounded px-0.5">{text.slice(idx, idx + query.length)}</mark>
      {text.slice(idx + query.length)}
    </span>
  );
}

// ── Content block renderer ───────────────────────────────────────────
function ContentBlock({ content, searchQuery }) {
  // Parse content string into blocks: paragraphs, code, tables, checklists
  const blocks = useMemo(() => parseContentBlocks(content), [content]);

  return (
    <div className="space-y-3">
      {blocks.map((block, i) => {
        switch (block.type) {
          case "mermaid":
            return <MermaidBlock key={i} code={block.content} />;
          case "code":
            return <CodeBlock key={i} language={block.language} code={block.content} />;
          case "table":
            return <MarkdownTable key={i} rows={block.rows} />;
          case "checklist":
            return <Checklist key={i} items={block.items} />;
          case "paragraph":
          default:
            return (
              <p key={i} className="text-sm text-slate-700 leading-relaxed">
                {renderInlineMarkdown(block.content, searchQuery)}
              </p>
            );
        }
      })}
    </div>
  );
}

// ── Block parsers ────────────────────────────────────────────────────
function parseContentBlocks(content) {
  if (!content) return [];
  const blocks = [];
  const lines = content.split("\n");
  let i = 0;

  while (i < lines.length) {
    const line = lines[i];

    // Fenced code block
    const codeMatch = line.match(/^```(\w*)/);
    if (codeMatch) {
      const lang = codeMatch[1] || "";
      const codeLines = [];
      i++;
      while (i < lines.length && !lines[i].startsWith("```")) {
        codeLines.push(lines[i]);
        i++;
      }
      i++; // skip closing ```
      if (lang === "mermaid") {
        blocks.push({ type: "mermaid", content: codeLines.join("\n") });
      } else {
        blocks.push({ type: "code", language: lang, content: codeLines.join("\n") });
      }
      continue;
    }

    // Table (line starts with |)
    if (line.trim().startsWith("|")) {
      const tableLines = [];
      while (i < lines.length && lines[i].trim().startsWith("|")) {
        tableLines.push(lines[i]);
        i++;
      }
      const rows = tableLines
        .filter(l => !l.match(/^\|\s*[-:]+/)) // skip separator
        .map(l => l.split("|").filter(Boolean).map(c => c.trim()));
      blocks.push({ type: "table", rows });
      continue;
    }

    // Checklist
    if (line.match(/^[-*]\s*\[[ x]\]/i)) {
      const items = [];
      while (i < lines.length && lines[i].match(/^[-*]\s*\[[ x]\]/i)) {
        const checked = lines[i].match(/\[x\]/i) !== null;
        const text = lines[i].replace(/^[-*]\s*\[[ x]\]\s*/i, "");
        items.push({ checked, text });
        i++;
      }
      blocks.push({ type: "checklist", items });
      continue;
    }

    // Paragraph (accumulate non-empty lines)
    if (line.trim()) {
      const paraLines = [];
      while (i < lines.length && lines[i].trim() && !lines[i].match(/^```/) && !lines[i].trim().startsWith("|") && !lines[i].match(/^[-*]\s*\[[ x]\]/i)) {
        paraLines.push(lines[i]);
        i++;
      }
      blocks.push({ type: "paragraph", content: paraLines.join(" ") });
      continue;
    }

    i++; // skip blank lines
  }
  return blocks;
}

// ── Mermaid rendering ────────────────────────────────────────────────
function MermaidBlock({ code }) {
  const containerRef = useRef(null);
  const [svg, setSvg] = useState(null);
  const [error, setError] = useState(false);
  const idRef = useRef(`mermaid-${Math.random().toString(36).slice(2, 9)}`);

  useEffect(() => {
    let cancelled = false;
    async function render() {
      try {
        if (!window.mermaid) {
          // Load mermaid from CDN
          await new Promise((resolve, reject) => {
            if (document.querySelector('script[data-mermaid]')) {
              const check = setInterval(() => {
                if (window.mermaid) { clearInterval(check); resolve(); }
              }, 100);
              return;
            }
            const s = document.createElement("script");
            s.src = "https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js";
            s.dataset.mermaid = "true";
            s.onload = () => {
              window.mermaid.initialize({ startOnLoad: false, theme: "neutral", securityLevel: "loose" });
              resolve();
            };
            s.onerror = reject;
            document.head.appendChild(s);
          });
        }
        const { svg: rendered } = await window.mermaid.render(idRef.current, code);
        if (!cancelled) setSvg(rendered);
      } catch {
        if (!cancelled) setError(true);
      }
    }
    render();
    return () => { cancelled = true; };
  }, [code]);

  if (error) {
    return <CodeBlock language="mermaid" code={code} />;
  }
  if (!svg) {
    return <div className="border border-slate-200 rounded-lg p-6 text-sm text-slate-400 text-center">Rendering diagram…</div>;
  }
  return (
    <div className="border border-slate-200 rounded-lg bg-white p-4 overflow-x-auto">
      <div dangerouslySetInnerHTML={{ __html: svg }} />
    </div>
  );
}

// ── Code block ───────────────────────────────────────────────────────
function CodeBlock({ language, code }) {
  const [copied, setCopied] = useState(false);
  const handleCopy = () => {
    navigator.clipboard.writeText(code);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };
  return (
    <div className="relative group rounded-lg overflow-hidden">
      {language && (
        <div className="bg-slate-700 text-slate-400 text-xs px-3 py-1 font-mono">{language}</div>
      )}
      <pre className="bg-slate-800 text-slate-100 p-4 overflow-x-auto text-xs font-mono leading-relaxed">
        <code>{code}</code>
      </pre>
      <button
        onClick={handleCopy}
        className="absolute top-2 right-2 p-1.5 rounded bg-slate-700 text-slate-300 opacity-0 group-hover:opacity-100 transition-opacity hover:bg-slate-600"
      >
        {copied ? <Check size={14} /> : <Copy size={14} />}
      </button>
    </div>
  );
}

// ── Table ────────────────────────────────────────────────────────────
function MarkdownTable({ rows }) {
  if (!rows || rows.length === 0) return null;
  const [header, ...body] = rows;
  return (
    <div className="overflow-x-auto rounded-lg border border-slate-200">
      <table className="w-full text-sm">
        <thead>
          <tr className="bg-slate-50">
            {header.map((cell, i) => (
              <th key={i} className="px-3 py-2 text-left font-semibold text-slate-700 border-b border-slate-200">{cell}</th>
            ))}
          </tr>
        </thead>
        <tbody>
          {body.map((row, i) => (
            <tr key={i} className={i % 2 === 1 ? "bg-slate-50/50" : ""}>
              {row.map((cell, j) => (
                <td key={j} className="px-3 py-2 text-slate-600 border-b border-slate-100">{cell}</td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

// ── Checklist ────────────────────────────────────────────────────────
function Checklist({ items }) {
  const done = items.filter(i => i.checked).length;
  return (
    <div className="space-y-1">
      <div className="text-xs text-slate-400 font-medium mb-2">{done}/{items.length} complete</div>
      {items.map((item, i) => (
        <div key={i} className={`flex items-start gap-2 text-sm ${item.checked ? "text-slate-400 line-through" : "text-slate-700"}`}>
          {item.checked ? <CheckSquare size={16} className="text-green-500 mt-0.5 shrink-0" /> : <Square size={16} className="text-slate-300 mt-0.5 shrink-0" />}
          <span>{item.text}</span>
        </div>
      ))}
    </div>
  );
}

// ── Frontmatter card ─────────────────────────────────────────────────
function FrontmatterCard({ data }) {
  if (!data || Object.keys(data).length === 0) return null;
  const special = ["title", "status", "version", "author", "date"];
  const title = data.title || data.name;
  const statusColors = {
    draft: "bg-amber-100 text-amber-800",
    "in-progress": "bg-blue-100 text-blue-800",
    review: "bg-purple-100 text-purple-800",
    done: "bg-green-100 text-green-800",
    complete: "bg-green-100 text-green-800",
  };
  const statusClass = data.status ? (statusColors[data.status.toLowerCase()] || "bg-slate-100 text-slate-700") : null;

  return (
    <div className="bg-white border border-slate-200 rounded-lg p-4 mb-4">
      {title && <h1 className="text-xl font-semibold text-slate-900 mb-2">{title}</h1>}
      <div className="flex flex-wrap gap-3 text-xs">
        {data.status && <span className={`px-2 py-1 rounded-full font-medium ${statusClass}`}>{data.status}</span>}
        {data.version && <span className="px-2 py-1 rounded-full bg-slate-100 text-slate-600">v{data.version}</span>}
        {data.author && <span className="text-slate-500">by {data.author}</span>}
        {data.date && <span className="text-slate-500">{data.date}</span>}
      </div>
      {Object.entries(data).filter(([k]) => !special.includes(k) && k !== "name").length > 0 && (
        <div className="mt-3 grid grid-cols-2 gap-x-4 gap-y-1 text-xs">
          {Object.entries(data).filter(([k]) => !special.includes(k) && k !== "name").map(([k, v]) => (
            <div key={k}><span className="text-slate-400">{k}:</span> <span className="text-slate-600">{String(v)}</span></div>
          ))}
        </div>
      )}
    </div>
  );
}

// ── Collapsible section ──────────────────────────────────────────────
function CollapsibleSection({ section, collapsed, onToggle, searchQuery, depth = 0 }) {
  const headingRef = useRef(null);
  const sizes = { 2: "text-xl", 3: "text-lg", 4: "text-base", 5: "text-sm", 6: "text-sm" };
  const sizeClass = sizes[section.level] || "text-base";

  return (
    <div ref={headingRef} data-section-id={section.id} className={depth > 0 ? "ml-2 border-l-2 border-slate-100 pl-4" : ""}>
      <button
        onClick={() => onToggle(section.id)}
        className="w-full flex items-center gap-2 py-2 text-left group hover:bg-slate-50 rounded-md px-2 -mx-2 transition-colors"
      >
        {collapsed ? <ChevronRight size={16} className="text-slate-400 shrink-0" /> : <ChevronDown size={16} className="text-slate-400 shrink-0" />}
        <span className={`font-semibold text-slate-900 ${sizeClass}`}>
          {renderInlineMarkdown(section.title, searchQuery)}
        </span>
      </button>

      {!collapsed && (
        <div className="pl-6 pb-3 space-y-3">
          {section.content && <ContentBlock content={section.content} searchQuery={searchQuery} />}
          {section.children?.map(child => (
            <CollapsibleSection
              key={child.id}
              section={child}
              collapsed={collapsed}
              onToggle={onToggle}
              searchQuery={searchQuery}
              depth={depth + 1}
            />
          ))}
        </div>
      )}
    </div>
  );
}

// ── Sidebar ToC ──────────────────────────────────────────────────────
function Sidebar({ sections, activeId, onNavigate, searchQuery }) {
  function filterSections(sections) {
    if (!searchQuery) return sections;
    return sections.filter(s => {
      const match = s.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
                    (s.content && s.content.toLowerCase().includes(searchQuery.toLowerCase()));
      const childMatch = s.children && filterSections(s.children).length > 0;
      return match || childMatch;
    });
  }

  function renderTocItem(section, depth = 0) {
    const isActive = section.id === activeId;
    const filtered = filterSections(section.children || []);
    return (
      <div key={section.id}>
        <button
          onClick={() => onNavigate(section.id)}
          className={`w-full text-left px-3 py-1.5 text-sm rounded-md transition-colors truncate
            ${isActive ? "bg-blue-600/20 text-blue-400 font-medium" : "text-slate-400 hover:text-slate-200 hover:bg-slate-800"}`}
          style={{ paddingLeft: `${12 + depth * 16}px` }}
        >
          {section.title}
        </button>
        {filtered.map(child => renderTocItem(child, depth + 1))}
      </div>
    );
  }

  const filtered = filterSections(sections);
  return (
    <nav className="space-y-0.5 py-2">
      {filtered.map(s => renderTocItem(s))}
    </nav>
  );
}

// ── Root component ───────────────────────────────────────────────────
export default function SpecObserver() {
  const [activeFile, setActiveFile] = useState(0);
  const [searchQuery, setSearchQuery] = useState("");
  const [collapsedSections, setCollapsedSections] = useState(new Set());
  const [activeSection, setActiveSection] = useState(null);
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const contentRef = useRef(null);
  const searchRef = useRef(null);

  const file = SPEC_DATA.files[activeFile];
  const allSections = useMemo(() => flattenSections(file?.sections || []), [file]);
  const totalChecks = useMemo(() => countChecks(file?.sections || []), [file]);

  // Initialize default collapsed state: h2 expanded, h3+ collapsed
  useEffect(() => {
    const defaultCollapsed = new Set();
    allSections.forEach(s => { if (s.level >= 3) defaultCollapsed.add(s.id); });
    setCollapsedSections(defaultCollapsed);
  }, [activeFile]);

  // Keyboard shortcut: Cmd+K to focus search
  useEffect(() => {
    const handler = (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === "k") {
        e.preventDefault();
        searchRef.current?.focus();
      }
    };
    window.addEventListener("keydown", handler);
    return () => window.removeEventListener("keydown", handler);
  }, []);

  // Scroll tracking for active ToC item
  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        for (const entry of entries) {
          if (entry.isIntersecting) {
            setActiveSection(entry.target.dataset.sectionId);
          }
        }
      },
      { rootMargin: "-20% 0px -70% 0px" }
    );
    const headings = contentRef.current?.querySelectorAll("[data-section-id]");
    headings?.forEach(h => observer.observe(h));
    return () => observer.disconnect();
  }, [activeFile, collapsedSections]);

  const toggleSection = useCallback((id) => {
    setCollapsedSections(prev => {
      const next = new Set(prev);
      if (next.has(id)) next.delete(id);
      else next.add(id);
      return next;
    });
  }, []);

  const navigateToSection = useCallback((id) => {
    setCollapsedSections(prev => {
      const next = new Set(prev);
      next.delete(id);
      // Also expand parents
      allSections.forEach(s => {
        if (s.children?.some(c => c.id === id)) next.delete(s.id);
      });
      return next;
    });
    setTimeout(() => {
      document.querySelector(`[data-section-id="${id}"]`)?.scrollIntoView({ behavior: "smooth", block: "start" });
    }, 50);
  }, [allSections]);

  const expandAll = () => setCollapsedSections(new Set());
  const collapseAll = () => setCollapsedSections(new Set(allSections.map(s => s.id)));

  return (
    <div className="h-screen flex flex-col bg-slate-50 overflow-hidden">
      {/* Header */}
      <div className="bg-white border-b border-slate-200 px-4 py-2 flex items-center gap-3 shrink-0">
        <button className="md:hidden p-1" onClick={() => setSidebarOpen(!sidebarOpen)}>
          {sidebarOpen ? <X size={20} /> : <Menu size={20} />}
        </button>
        <div className="relative flex-1 max-w-md">
          <Search size={16} className="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400" />
          <input
            ref={searchRef}
            type="text"
            placeholder="Search spec… (⌘K)"
            value={searchQuery}
            onChange={e => setSearchQuery(e.target.value)}
            className="w-full pl-9 pr-3 py-1.5 text-sm border border-slate-200 rounded-lg bg-slate-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:bg-white"
          />
        </div>
        <div className="flex gap-1 ml-auto">
          <button onClick={expandAll} className="text-xs text-slate-500 hover:text-slate-700 px-2 py-1 rounded hover:bg-slate-100">Expand all</button>
          <button onClick={collapseAll} className="text-xs text-slate-500 hover:text-slate-700 px-2 py-1 rounded hover:bg-slate-100">Collapse all</button>
        </div>
        {SPEC_DATA.files.length > 1 && (
          <div className="flex border border-slate-200 rounded-lg overflow-hidden ml-2">
            {SPEC_DATA.files.map((f, i) => (
              <button
                key={i}
                onClick={() => setActiveFile(i)}
                className={`flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium transition-colors
                  ${i === activeFile ? "bg-slate-900 text-white" : "text-slate-600 hover:bg-slate-50"}`}
              >
                <FileText size={12} />
                {f.name}
              </button>
            ))}
          </div>
        )}
      </div>

      {/* Body */}
      <div className="flex flex-1 overflow-hidden">
        {/* Sidebar */}
        <aside className={`w-64 bg-slate-900 border-r border-slate-800 overflow-y-auto shrink-0 transition-transform
          ${sidebarOpen ? "translate-x-0" : "-translate-x-full"} md:translate-x-0
          ${sidebarOpen ? "absolute z-20 h-full" : "hidden md:block"}`}>
          <div className="px-3 pt-4 pb-2">
            <span className="text-xs font-semibold text-slate-500 uppercase tracking-wider">Contents</span>
          </div>
          <Sidebar
            sections={file?.sections || []}
            activeId={activeSection}
            onNavigate={(id) => { navigateToSection(id); setSidebarOpen(false); }}
            searchQuery={searchQuery}
          />
        </aside>

        {/* Content */}
        <main ref={contentRef} className="flex-1 overflow-y-auto px-6 md:px-10 py-6 max-w-4xl">
          {file?.frontmatter && <FrontmatterCard data={file.frontmatter} />}
          <div className="space-y-2">
            {file?.sections?.map(section => (
              <CollapsibleSection
                key={section.id}
                section={section}
                collapsed={collapsedSections.has(section.id)}
                onToggle={toggleSection}
                searchQuery={searchQuery}
              />
            ))}
          </div>
        </main>
      </div>

      {/* Status bar */}
      <div className="bg-white border-t border-slate-200 px-4 py-1.5 flex items-center gap-4 text-xs text-slate-400 shrink-0">
        <span className="font-medium text-slate-600">SpecObserver</span>
        <span>{SPEC_DATA.files.length} file{SPEC_DATA.files.length !== 1 ? "s" : ""}</span>
        <span>{allSections.length} sections</span>
        {totalChecks.total > 0 && (
          <span className="flex items-center gap-1">
            <CheckSquare size={12} className="text-green-500" />
            {totalChecks.done}/{totalChecks.total} tasks
          </span>
        )}
      </div>
    </div>
  );
}

// ── Helpers ──────────────────────────────────────────────────────────
function flattenSections(sections) {
  const flat = [];
  for (const s of sections) {
    flat.push(s);
    if (s.children) flat.push(...flattenSections(s.children));
  }
  return flat;
}

function countChecks(sections) {
  let done = 0, total = 0;
  for (const s of sections) {
    const matches = s.content?.match(/- \[([ x])\]/gi) || [];
    matches.forEach(m => { total++; if (m.includes("[x]") || m.includes("[X]")) done++; });
    if (s.children) {
      const child = countChecks(s.children);
      done += child.done;
      total += child.total;
    }
  }
  return { done, total };
}
```

## Key implementation notes

1. **CollapsibleSection handles its own children recursively** — the parent's collapsed state controls whether children are visible at all, and each child manages its own collapsed state independently.

2. **Search filters both the ToC and highlights in content** — the sidebar filters out non-matching sections, while the content area wraps matches in `<mark>` tags.

3. **Mermaid loads lazily** — the CDN script is only fetched when the first mermaid block mounts. This keeps the artifact fast when no diagrams exist.

4. **The agent replaces `SPEC_DATA`** with the actual parsed spec JSON. This is the only part that changes between generations.
